2D Parsing

[!] Best way to parse an array of characters, identifying symbols made up of
	multiple lines of characters. Symbols would be defined as 2D patterns - 
	the 2D equivalent of regular expressions
[!] Best way to define 2D symbols

     a
  +-----+     a == b
c |     |     c == d
  |     | d
  +-----+
     b

  \+(-+)\+\n         |$1| syntax gets length of match
  (\| {|$1|}\|\n)+   Wow that expression is ugly
  \+$1\+\n           Successfully collapses 2d symbol into 
                     1d regex, though

Special part is the handling of newlines - newlines continue from symbol
on next line down from start of pattern


\.(-{5,})\.\n         These really are horrendously ugly.
('-{|$1|}'\n)         They look nothing like their resulting symbol
(\| {|$1|}\|\n){1,}   Might be a way to bootstrap the parsing chain, anyway!
$2                    Could use linear regexes to parse the symbol definitions,
                      whatever they're going to look like

      left     left
( + )-->--( - )-->--( + )
  |        ^ |
  v        '-'
  |down     left
( | )-.
  | ^ | down
  v '-'
  | down
( + )

[!] Newlining to a space *before* the start of the line above
- would need syntax for going back spaces, e.g. "^{5}"

  /\
 /  \   Diamonds:
/    \  (/( {$L*2})\\\n)+
\    /  (\\( {(|$1|-($L-|$1|))*2})/\n)+
 \  /
  \/    Diamond isn't possible without quantifiers proportional to 
        line number and other crazy arithmetic in the quantifier 
        bracket

[!] Need to *record* state in order to linear-ise some of these patterns.

REs deficiency for this problem is equivalent to the following 1D problem:

	all 2:1 ratio forms of "sssshh"

Here we'd need to remember the number of S's in order to match the H's.

[?] Can a more general grammar express this?

S -> A
A -> 's' 's' B 'h'
B -> A | e

sssssshhh:

S
'-- A
    |-- 's'
    |-- 's'
    |-- B
    |   '-- A
    |       |-- 's'
    |       |-- 's'
    |       |-- B
    |       |   '-- A
    |       |       |-- 's'
    |       |       |-- 's'
    |       |       |-- B
    |       |       |   '-- e
    |       |       '-- 'h' 
    |       '-- 'h'
    '-- 'h'

[?] Ok, so what about 3:2:1 ratio forms of "aaaggh" ?
- Yeah I haven't got a clue, there. Nothing springs to mind. Its not a case of finding
  an X for every Y, so the presence of a stack won't help - a bespoke algorithm is 
  required.

(aaa)+(gg){|$1|}(h){|$1|}
            ^
          Have to refer to a variable in which we store 
          the number of times we've matched something.

( "Scream" (
	( one-or-more 
		( capture-group
			( "a" "a" "a" )))
	( let x 
		( size-of
			( backref 1 ))
		(
			( n-of x ( "g" "g" ))
			( n-of x "h" )))))
				
S-Expressions are a data representation. They're merely nested lists. There are 
parentheses, symbols, strings and numbers (afaik). What the nested lists represent 
is entirely up to the application.

[?] How is lisp evaluated? 
- I guess each component is evaluated in order. 
[?] How does lisp recognise a function?
- I guess there's logic that looks up the first symbol of of list to see if its a 
function. I wonder if every list starting with a symbol is assumed to be a function.
- I guess the interpreter could make a decision based on what it finds in the list. 
The first atom in the list would dicatate how to continue to evaluate it.

- Lisp evaluates lists by treating the first atom as a function name and the rest
as arguments. However, macros can override this to create arbitrary syntax.

- So I could do the same - have a fixed set of functions with their own evaluation
  rules. The language doesn't even need to be turing complete.
- The program could evaluate lone string literals by attempting to consume that 
  character, returning a boolean to indicate success.
  
(def-symbol "box"
	(with-vars (first-line mid-bar) 
		(capture first-line 
			(one "+") (capture mid-bar (one-or-more "-")) (one "+") (eol))
		(one-or-more (one "|") (n-of (width mid-bar) " ") (one "|") (eol))
		(one first-line)))
		
- fn def-symbol name stmt stmt ... -> nil
		defines a new symbol pattern
- fn with-vars (var var ...) stmt stmt ... -> nil
		creates variables for the scope of the statements
- fn capture var stmt stmt ... -> nil
		buffers consumed input for inner statements and stores it in var. The buffer
		is built as the statements are evaluated.
- fn one str str ... -> boolean 
		attempts to consume the given list of strings		
- fn one-or-more str str ... -> boolean
		attempts to consume the given list of strings at least once. Returns true
		if this was the case, false otherwise
- fn zero-or-more str str ... -> boolean
		attempts to consume the given list of strings multiple times. Returns 
		true regardless of how many times this succeeded
- fn zero-or-one str str ... -> boolean
		attempts to consume the given list of strings once, returning true whether 
		it succeeded or not
- fn n-of n str str ... -> boolean
		attempts to consume the given list of strings exactly n times, returning 
		false if this fails
- fn width str -> int
		returns the width in characters of the given string - that is, the length
		of the longest line.
- fn height str -> int
		returns the height in characters of the given string - that is, the number
		of lines it contains.
- fn eol [int] -> nil
		indicates the end of a pattern's line. Can specify the relative offset of 
		the new line start position in characters. 0 or unspecified indicates the 
		new line begins directly under the current one. -2 indicates the new line
		begins 2 characters left of the current one.
- fn - int int ... -> int
		subtracts the given integers from one another, returning the result
- fn + int int ... -> int
		adds the given integers to each other, returning the result
- fn * int int ... -> int
		multiplies the given integers with each other, returning the result
- fn / int int ... -> int
		divides the given integers by each other, returning the result
		
(def-symbol "diamond"
	(with-vars (top bottom)
		(capture top 
			(one-or-more
				(one "/")
				(n-of (- (height top) 1) " ")
				(one "\\")
				(eol)))
		(capture bottom
			(n-of (height top)
				(one "\\")
				(n-of (- (height top)(height bottom)) " ")
				(one "/")
				(eol)))))

This definition relies on being able to monitor the height of a captured
buffer as it is being buffered.

[!] I need a special function, like the newline function, to indicate empty space
    i.e. characters which are allowed to have other patterns occupying them.
    For example, a box is allowed to have other patterns inside it.

[!] Patterns need to be able to look ahead to what the *next* character is.

Pattern: bc

[a][b][c][d]  [a][b][c][d]  [a][b][c][d]  [a][b][c][d]
 ^                ^                ^                ^
next (nope)     next (make)      next (more)      next (complete)

[!] Need an arbitraty length of look-ahead e.g: "a(bcdef)?
    i.e, backtracking
    
X: a(bcdef)?
    +
Y: abc
 =                
                   
   a     b     c     d     e     f
(s)-->(1)--> 2 -->(3)--> 4 --> 5 -->(6)
       X           Y                 X

[!] Buildup of potential patterns

a+
    
a a a a a a a a a a a a a a a 
V_/_/_/_/
  V_/_/_/
    V_/_/ ....
      V_/
        V
        
[!] Pattern priorities

              b eliminates    d eliminates
               a and c         b, freeing up a and c
                  v             v
- - - - - - - - - - - - - - - - -
    \_____________/
  \___/ b \___/ \_______________/
    a       c           d

- Patterns have a priority order
- Scan the canvas from left to right, a line at a time. 
- For each patten in the ongoing list in priority order, test whether they accept the 
  current character
- Pattern will return "more", "complete" or "aborted" to indicate their state.
- "Aborted" means the pattern didnt match - it is removed from the ongoing list.
- "More" means the pattern accepted the character but is not complete yet
- "Complete" means the pattern is fully matched - the matching pattern is recorded as
  a potential pattern position
- Identify any patterns which might begin with the current character and add them to
  the ongoing list.

[*] Why not get it working the simplest way first - make a pass for each pattern, in
    priority order, trying to find matches

[?] Any reason why I shouldn't discard other ongoing instances of the same pattern 
    upon finding a match?
- Matches are greedy, I think

ababab
a b a b a b a b
\_________/
    \_________/     Should be ok
        \______
            \__

[?] Can we get away with not allowing any other ongoing instances at all?

bbba
b b b b a
\_____x
  \_____/    No, we would miss valid matches.
    \___x
      \_x

[*] Upon matching multiple instances of the same pattern at once, should accept the 
    oldest one.

[!] Discarding ongoing patterns fails for multi-line patterns. Such patterns are 
    allowed to overlap (effectively)

[!] Ongoing instances need to somehow record the characters they consist of, so 
    that other overlapping instances are aborted upon finding a match.
    
[?] In what way should the transformation from ascii pattern to vector be
    defined? 
- For each matched pattern, the constituent cells and their contents must 
  be recorded. 
- The pattern will need to note the positions of particular vertices and such.
- e.g. for the database cylinder, matcher would note the height of the top
  and bottom circles, and the width and height of the overall pattern
  
          .--------.   ^ top      - Having noted these values, pattern can
       ^  '--------'   v height     later return the necessary shapes, positioned
bottom |  |        |                relative to the first cell of the match
height |  |        |   ^ bottom   
       v  '--------'   v height
          <-------->
            width

[*] Storing values can be boiled down to recording the current cell position
    in various variables during the match - noting key locations for later
    calculating widths and heights

[*] The current character can also be stored or tested during the match, in
    order to identify optional stuff

[!] Completed matches must be stored somewhere along with the cells they occupy
    so that they can be tested for on subsequent passes

[!] Some components such as box connectors need to test for what type of pattern
    a character is part of and, indeed, what aspect of the pattern the character 
    is - e.g. left or right side of a box
    
   .------------.  
  (              )
 (                )
 (                )
 (                )
  (              )
   '------------'

[!] Should be able to set meta data separately from whether a space is occupied
    or not.
- On completion of a pattern match, it should stamp the board with an array of
  metadata which is combined with other patterns' data.

[*] matcher could return metadata for each character as it matches it. It's 
    assumed that the progress of a pattern can be determined by the current
    character anyway
- instead of accept or ignore, could simply return metadata. 
- Could have a metadata flag to say whether a space is occupied or not
- If matcher returns no flags, and none is set on the space already, no need
  to store any data

[!] Inter-instance overlaps. An instance isn't aware of another until it becomes
    a match. But at that point, the instance only needs to be removed if it 
    no longer fits in the space.
- So the instance manager must note when instances return M_OCCUPIED and store
  a reference to them for that position. 
- If another instance matches, any other instances that clash for its occupied
  spaces must be removed.
  
occupiers = { (1,2): [instA,instF], (4,5): [instD] }

- But we must also store each instance's effect on the grid's metadata:

matches_meta = { instA: { (0,2): M_FOO, (1,2): M_OCCUPIED },
					instD: { (4,5): M_OCCUPIED, (10,11): M_BAR },
					instF: { (1,2): M_OCCUPIED, (10,11): M_BLAH } }

  cooccs 
  cleared
     V
---+---\n
01234
 0123
  012 
   01  
    0123
     012
      01
       00

[!] The input "---+---". The horizontal line instances can't share the corner because
    they both try to occupy it, and the first eliminates the second, leaving only the
    instance that didn't include the corner.
- If they don't try to occupy it, it's going to become a literal '+', too.

[*] Bit of a hack, but could have horiz line match runs of lines as a single line 
    instance
- Makes arrowheads, etc harder to match and render if there are multiple per 
  instance.
  
  + + +    Could line corners be done in a different pass? As a separate pattern?
   \|/     So lines include them but leave them unoccupied, and mark their characters
  +-+-+    as lines
   /|\     Then another pattern matches + symbols at line intersections
  + + +

Pattern matching thing seems to work pretty well. 

[?] Is there a more elegant way to express these patterns? 
[?] Are s-expressions the way to go?
- Its going to be some kind of DSL, which is either evaluated at runtime or converted
  to python code.
- S-expressions are a lazy, parenthesis-laden way of implementing this. Not necessarily
  a bad thing.
- DSL would have to describe not only the pattern to match, but the metadata for each
  character and where to draw shapes for the output.
  
[!] Patterns have nothing in the way of backtracking - a character is either accepted
    or rejected and the decision to occupy must be immediate
[?] Could a pattern like the following even be matched?

string of triangles:

/_\/_\/_\/_\

(/_\)+

Best we can do is end if the next character after a triangle is not a forward slash.
But this means that if there's an incomplete triangle on the end, the whole match will
fail instead of accepting the complete triangles.
       __
/_\/_\/_/|
      |_|/
  ^
triangle match fails

Ok, but the matching is pretty flexible anyway. The DSL would just have to restrict
operations to single characters at a time - i.e. no (#? / _ \)

(p box 
	($ start (@))
	(1 + line-square-corner)
	($ midw (w (1+ -)))
	(1 + line-square-corner)
	(1+
		(1 |)
		(n ($ midw) spc)
		(1 |))
	(1 + line-square-corner)
	(n ($midw) -)
	($ end (@))
	(1 + line-square-corner)

Or (1+ (1 :) (1: rb)) is allowed, but user just has to bear in mind the problem above.

[?] How to do curved lines?

----.          . is like + but only allows down lines
    |         
    '-----     ' is like + but only allows up lines
    
----.----  Allow this? Why not. So this would look like an M:  .--.--.
    |                                                          |  |  |
                                   \    \    \    \
What to use for lines like this?    +    '    .    :  Require the colon?
                                    |    |    |    |
  .---.
 /     \     .----.  /-----\   I should have a pattern for 
:       :    |    |  |     |   diagonal-cornered boxes, as this is a 
|       |    |    |  |     |   common convention.
:       :    '----'  \-----/
 \     /
  '---'

