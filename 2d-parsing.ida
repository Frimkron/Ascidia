2D Parsing

[!] Best way to parse an array of characters, identifying symbols made up of
	multiple lines of characters. Symbols would be defined as 2D patterns - 
	the 2D equivalent of regular expressions
[!] Best way to define 2D symbols

     a
  +-----+     a == b
c |     |     c == d
  |     | d
  +-----+
     b

  \+(-+)\+\n         |$1| syntax gets length of match
  (\| {|$1|}\|\n)+   Wow that expression is ugly
  \+$1\+\n           Successfully collapses 2d symbol into 
                     1d regex, though

Special part is the handling of newlines - newlines continue from symbol
on next line down from start of pattern


\.(-{5,})\.\n         These really are horrendously ugly.
('-{|$1|}'\n)         They look nothing like their resulting symbol
(\| {|$1|}\|\n){1,}   Might be a way to bootstrap the parsing chain, anyway!
$2                    Could use linear regexes to parse the symbol definitions,
                      whatever they're going to look like

      left     left
( + )-->--( - )-->--( + )
  |        ^ |
  v        '-'
  |down     left
( | )-.
  | ^ | down
  v '-'
  | down
( + )

[!] Newlining to a space *before* the start of the line above
- would need syntax for going back spaces, e.g. "^{5}"

  /\
 /  \   Diamonds:
/    \  (/( {$L*2})\\\n)+
\    /  (\\( {(|$1|-($L-|$1|))*2})/\n)+
 \  /
  \/    Diamond isn't possible without quantifiers proportional to 
        line number and other crazy arithmetic in the quantifier 
        bracket

[!] Need to *record* state in order to linear-ise some of these patterns.

REs deficiency for this problem is equivalent to the following 1D problem:

	all 2:1 ratio forms of "sssshh"

Here we'd need to remember the number of S's in order to match the H's.

[?] Can a more general grammar express this?

S -> A
A -> 's' 's' B 'h'
B -> A | e

sssssshhh:

S
'-- A
    |-- 's'
    |-- 's'
    |-- B
    |   '-- A
    |       |-- 's'
    |       |-- 's'
    |       |-- B
    |       |   '-- A
    |       |       |-- 's'
    |       |       |-- 's'
    |       |       |-- B
    |       |       |   '-- e
    |       |       '-- 'h' 
    |       '-- 'h'
    '-- 'h'

[?] Ok, so what about 3:2:1 ratio forms of "aaaggh" ?
- Yeah I haven't got a clue, there. Nothing springs to mind. Its not a case of finding
  an X for every Y, so the presence of a stack won't help - a bespoke algorithm is 
  required.

(aaa)+(gg){|$1|}(h){|$1|}
            ^
          Have to refer to a variable in which we store 
          the number of times we've matched something.

( "Scream" (
	( one-or-more 
		( capture-group
			( "a" "a" "a" )))
	( let x 
		( size-of
			( backref 1 ))
		(
			( n-of x ( "g" "g" ))
			( n-of x "h" )))))
				
S-Expressions are a data representation. They're merely nested lists. There are 
parentheses, symbols, strings and numbers (afaik). What the nested lists represent 
is entirely up to the application.

[?] How is lisp evaluated? 
- I guess each component is evaluated in order. 
[?] How does lisp recognise a function?
- I guess there's logic that looks up the first symbol of of list to see if its a 
function. I wonder if every list starting with a symbol is assumed to be a function.
- I guess the interpreter could make a decision based on what it finds in the list. 
The first atom in the list would dicatate how to continue to evaluate it.

- Lisp evaluates lists by treating the first atom as a function name and the rest
as arguments. However, macros can override this to create arbitrary syntax.

- So I could do the same - have a fixed set of functions with their own evaluation
  rules. The language doesn't even need to be turing complete.
- The program could evaluate lone string literals by attempting to consume that 
  character, returning a boolean to indicate success.
  
(def-symbol "box"
	(with-vars (first-line mid-bar) 
		(capture first-line 
			(one "+") (capture mid-bar (one-or-more "-")) (one "+") (eol))
		(one-or-more (one "|") (n-of (width mid-bar) " ") (one "|") (eol))
		(one first-line)))
		
- fn def-symbol name stmt stmt ... -> nil
		defines a new symbol pattern
- fn with-vars (var var ...) stmt stmt ... -> nil
		creates variables for the scope of the statements
- fn capture var stmt stmt ... -> nil
		buffers consumed input for inner statements and stores it in var. The buffer
		is built as the statements are evaluated.
- fn one str str ... -> boolean 
		attempts to consume the given list of strings		
- fn one-or-more str str ... -> boolean
		attempts to consume the given list of strings at least once. Returns true
		if this was the case, false otherwise
- fn zero-or-more str str ... -> boolean
		attempts to consume the given list of strings multiple times. Returns 
		true regardless of how many times this succeeded
- fn zero-or-one str str ... -> boolean
		attempts to consume the given list of strings once, returning true whether 
		it succeeded or not
- fn n-of n str str ... -> boolean
		attempts to consume the given list of strings exactly n times, returning 
		false if this fails
- fn width str -> int
		returns the width in characters of the given string - that is, the length
		of the longest line.
- fn height str -> int
		returns the height in characters of the given string - that is, the number
		of lines it contains.
- fn eol [int] -> nil
		indicates the end of a pattern's line. Can specify the relative offset of 
		the new line start position in characters. 0 or unspecified indicates the 
		new line begins directly under the current one. -2 indicates the new line
		begins 2 characters left of the current one.
- fn - int int ... -> int
		subtracts the given integers from one another, returning the result
- fn + int int ... -> int
		adds the given integers to each other, returning the result
- fn * int int ... -> int
		multiplies the given integers with each other, returning the result
- fn / int int ... -> int
		divides the given integers by each other, returning the result
		
(def-symbol "diamond"
	(with-vars (top bottom)
		(capture top 
			(one-or-more
				(one "/")
				(n-of (- (height top) 1) " ")
				(one "\\")
				(eol)))
		(capture bottom
			(n-of (height top)
				(one "\\")
				(n-of (- (height top)(height bottom)) " ")
				(one "/")
				(eol)))))

This definition relies on being able to monitor the height of a captured
buffer as it is being buffered.

[!] I need a special function, like the newline function, to indicate empty space
    i.e. characters which are allowed to have other patterns occupying them.
    For example, a box is allowed to have other patterns inside it.

[!] Patterns need to be able to look ahead to what the *next* character is.

Pattern: bc

[a][b][c][d]  [a][b][c][d]  [a][b][c][d]  [a][b][c][d]
 ^                ^                ^                ^
next (nope)     next (make)      next (more)      next (complete)

[!] Need an arbitraty length of look-ahead e.g: "a(bcdef)?
    i.e, backtracking
    
X: a(bcdef)?
    +
Y: abc
 =                
                   
   a     b     c     d     e     f
(s)-->(1)--> 2 -->(3)--> 4 --> 5 -->(6)
       X           Y                 X

[!] Buildup of potential patterns

a+
    
a a a a a a a a a a a a a a a 
V_/_/_/_/
  V_/_/_/
    V_/_/ ....
      V_/
        V
        
[!] Pattern priorities

              b eliminates    d eliminates
               a and c         b, freeing up a and c
                  v             v
- - - - - - - - - - - - - - - - -
    \_____________/
  \___/ b \___/ \_______________/
    a       c           d

- Patterns have a priority order
- Scan the canvas from left to right, a line at a time. 
- For each patten in the ongoing list in priority order, test whether they accept the 
  current character
- Pattern will return "more", "complete" or "aborted" to indicate their state.
- "Aborted" means the pattern didnt match - it is removed from the ongoing list.
- "More" means the pattern accepted the character but is not complete yet
- "Complete" means the pattern is fully matched - the matching pattern is recorded as
  a potential pattern position
- Identify any patterns which might begin with the current character and add them to
  the ongoing list.

[*] Why not get it working the simplest way first - make a pass for each pattern, in
    priority order, trying to find matches

[?] Any reason why I shouldn't discard other ongoing instances of the same pattern 
    upon finding a match?
- Matches are greedy, I think

ababab
a b a b a b a b
\_________/
    \_________/     Should be ok
        \______
            \__

[?] Can we get away with not allowing any other ongoing instances at all?

bbba
b b b b a
\_____x
  \_____/    No, we would miss valid matches.
    \___x
      \_x

[*] Upon matching multiple instances of the same pattern at once, should accept the 
    oldest one.

[!] Discarding ongoing patterns fails for multi-line patterns. Such patterns are 
    allowed to overlap (effectively)

[!] Ongoing instances need to somehow record the characters they consist of, so 
    that other overlapping instances are aborted upon finding a match.
    
[?] In what way should the transformation from ascii pattern to vector be
    defined? 
- For each matched pattern, the constituent cells and their contents must 
  be recorded. 
- The pattern will need to note the positions of particular vertices and such.
- e.g. for the database cylinder, matcher would note the height of the top
  and bottom circles, and the width and height of the overall pattern
  
          .--------.   ^ top      - Having noted these values, pattern can
       ^  '--------'   v height     later return the necessary shapes, positioned
bottom |  |        |                relative to the first cell of the match
height |  |        |   ^ bottom   
       v  '--------'   v height
          <-------->
            width

[*] Storing values can be boiled down to recording the current cell position
    in various variables during the match - noting key locations for later
    calculating widths and heights

[*] The current character can also be stored or tested during the match, in
    order to identify optional stuff

[!] Completed matches must be stored somewhere along with the cells they occupy
    so that they can be tested for on subsequent passes

[!] Some components such as box connectors need to test for what type of pattern
    a character is part of and, indeed, what aspect of the pattern the character 
    is - e.g. left or right side of a box
    
   .------------.  
  (              )
 (                )
 (                )
 (                )
  (              )
   '------------'

[!] Should be able to set meta data separately from whether a space is occupied
    or not.
- On completion of a pattern match, it should stamp the board with an array of
  metadata which is combined with other patterns' data.

[*] matcher could return metadata for each character as it matches it. It's 
    assumed that the progress of a pattern can be determined by the current
    character anyway
- instead of accept or ignore, could simply return metadata. 
- Could have a metadata flag to say whether a space is occupied or not
- If matcher returns no flags, and none is set on the space already, no need
  to store any data

[!] Inter-instance overlaps. An instance isn't aware of another until it becomes
    a match. But at that point, the instance only needs to be removed if it 
    no longer fits in the space.
- So the instance manager must note when instances return M_OCCUPIED and store
  a reference to them for that position. 
- If another instance matches, any other instances that clash for its occupied
  spaces must be removed.
  
occupiers = { (1,2): [instA,instF], (4,5): [instD] }

- But we must also store each instance's effect on the grid's metadata:

matches_meta = { instA: { (0,2): M_FOO, (1,2): M_OCCUPIED },
					instD: { (4,5): M_OCCUPIED, (10,11): M_BAR },
					instF: { (1,2): M_OCCUPIED, (10,11): M_BLAH } }

  cooccs 
  cleared
     V
---+---\n
01234
 0123
  012 
   01  
    0123
     012
      01
       00

[!] The input "---+---". The horizontal line instances can't share the corner because
    they both try to occupy it, and the first eliminates the second, leaving only the
    instance that didn't include the corner.
- If they don't try to occupy it, it's going to become a literal '+', too.

[*] Bit of a hack, but could have horiz line match runs of lines as a single line 
    instance
- Makes arrowheads, etc harder to match and render if there are multiple per 
  instance.
  
  + + +    Could line corners be done in a different pass? As a separate pattern?
   \|/     So lines include them but leave them unoccupied, and mark their characters
  +-+-+    as lines
   /|\     Then another pattern matches + symbols at line intersections
  + + +

Pattern matching thing seems to work pretty well. 

[?] Is there a more elegant way to express these patterns? 
[?] Are s-expressions the way to go?
- Its going to be some kind of DSL, which is either evaluated at runtime or converted
  to python code.
- S-expressions are a lazy, parenthesis-laden way of implementing this. Not necessarily
  a bad thing.
- DSL would have to describe not only the pattern to match, but the metadata for each
  character and where to draw shapes for the output.
  
[!] Patterns have nothing in the way of backtracking - a character is either accepted
    or rejected and the decision to occupy must be immediate
[?] Could a pattern like the following even be matched?

string of triangles:

/_\/_\/_\/_\

(/_\)+

Best we can do is end if the next character after a triangle is not a forward slash.
But this means that if there's an incomplete triangle on the end, the whole match will
fail instead of accepting the complete triangles.
       __
/_\/_\/_/|
      |_|/
  ^
triangle match fails

Ok, but the matching is pretty flexible anyway. The DSL would just have to restrict
operations to single characters at a time - i.e. no (#? / _ \)

(p box 
	($ start (@))
	(1 + line-square-corner)
	($ midw (w (1+ -)))
	(1 + line-square-corner)
	(1+
		(1 |)
		(n ($ midw) spc)
		(1 |))
	(1 + line-square-corner)
	(n ($midw) -)
	($ end (@))
	(1 + line-square-corner)

Or (1+ (1 :) (1: rb)) is allowed, but user just has to bear in mind the problem above.

[?] How to do curved lines?

----.          . is like + but only allows down lines
    |         
    '-----     ' is like + but only allows up lines
    
----.----  Allow this? Why not. So this would look like an M:  .--.--.
    |                                                          |  |  |
                                   \    \    \    \
What to use for lines like this?    +    '    .    :  Require the colon?
                                    |    |    |    |
  .---.
 /     \     .----.  /-----\   I should have a pattern for 
:       :    |    |  |     |   diagonal-cornered boxes, as this is a 
|       |    |    |  |     |   common convention.
:       :    '----'  \-----/
 \     /
  '---'

Curve of corner line is dependent on the surrounding lines. Would have to draw them in
separately in the corner pass.


[H] . [H]   becomes  .._   _..
   [V]                  '.'

      [D]                  .'
[H] '       becomes   ...-'

   [V]                    .'.
[H] : [H]   becomes   --=:   :=-
   [V]                    '.'

g.send(input) -> output

g = gen()
g.next()
while True:
	curr = yield g.send(curr)

class Foo(object):
	getter = None
	gen = None
	def __init__(self,gen,getter):
		self.gen = gen
		self.getter = getter
		self.gen.next()
	def next(self):
		return self.gen.send(self.getter())

def await(pos):
	curr = None
	while curr != pos:
		curr = yield M_NONE

for meta in Foo(await(pos),getcurr):
	yield meta

'X   'X   'X
 \   |   /   '--'
  \  |  /
   ' ' '  
.    .    .
 \   |   /   .--.
  \  |  /
   .X.X.X

:    :    :
 \   |   /   :--:
  \  |  /
   : : :

  1 2 3
   \|/
  8-:-4 How to draw this rounded corner?
   /|\  Enumerate all posibilities?
  7 6 5
  
   1 w 2 3 4 5 6 7 8
   2 w 3 4 5 6 7 8
   3 w 4 5 6 7 8
   4 w 5 6 7 8
   5 w 6 7 8
   6 w 7 8
   7 w 8
       = 28 curves

\ | /
-   -
/ | \

Line meta flags are used to describe where adjoining lines are for corner spaces.
So they can't be used to decide where arrowheads are valid, because they are only
set where fullblown lines have been established.

Square corners are placed on +'s with the square corner flag set. They don't need 
line meta flags to be set. 4-way line meta flags could be set to allow arrowheads.
Round corners are placed on ' . or : where the round corner flag is set. They rely
on line meta flags to decide what curves to draw. Could set line metadata for 
unattached curves, allowing arrowheads.

[!]               .--   .-
So what about:  --'    .'  
.                     -'
And what about: <-.OK <-.OK <.OK <.FAIL
                  |     v    |    v
                  v          v
                  
Currently corners are defined by lines encountering corner characters.
But we'd like to be able to attach arrowheads to corners as if they were line 
endings in their own right.

[?] Under what circumstances do we consider . ' or : to be a corner? Must it be 
attached to a line?

   ..    Can't have corners defined in terms of other corners because this
  .''.   would be a recursive definition. Lines have to be the hint. But
 .'/\'.  are they the only hint?
 '.\/.'
  '..'   Should arrows be part of the line pattern? -->--
   ''    This would make sure arrows were definitely lines, allowing them to
         attach to corners.
         
  >-->-->. 
         |
        <'>
 
[*] It would greatly simply things if corners and line endings both required
  honest-to-goodness line segments to be present.
- should probably disallow corners that only connect to a single line.

[*] Line segments could drop a hint via a meta flag to indicate the space after
  their end.
- Square corners would use this to draw themselves - only match where more than one line end
- Round corners would use this to draw themselves - only match where more than one line end
- Arrowheads would use this to decide where they're valid

Lines behave in a simpler way now, I suppose. But I liked the curvyness of curved
corners curving from the centre of adjacent lines.
Previously lines knew when a corner was coming up and ended in the centre of the space
in preparation.

+---+---+  +---+---+  Oh well.
|   |_.-|  |  .----|
+---+---+  +-:-+---+
| .'|  vs  | | |
+-|-+      +-|-+

Down arrows require that if there is a character to the left or right, it is non-alphbetic, 
to avoid arrow insertion in the middle of words.

[!] Down arrow pattern makes left context optional. But requiring a left character means 
  arrow can't exist of left edge
- as luck would have it, down arrow can't exist without a line before it. So we can demand 
  the presence of a prior character, whether this is a linebreak or whatever

Diagonal dotted lines?
    +
   , `
  ,   `            +'''''''''+    +- - - - - -+   +- +  +- - - -+
 ,     `           :         :    '           '  ,   '  |       |
+       +.....>    :         :    '           ' ,    '        
:                  :         :    '           ',     '  |       |
:                  +.........+    +- - - - - -+      v  +- - - -+
v

Bugger. Apostraphes as vertical dashed lines *and* rounded corners make things way too
ambiguous. Use periods instead? Same problem!
                                                                         '      
.--.  ' .  How could dashed lines have rounded corners then, anyway?     '
|  |  ' .                                                                '- - - 
'--'  ' .  

Use colons instead? They're still rounded corners!

- - -.
     :
     :---
     :

[*] Could have ('.)+ for vertical dashes:

.- - - - -.   Not really intuitive. And messes with   .------.  
'         '   Closely-stacked, aligned boxes:         '------'  But that's not a 
.         .                                           .------.  valid box anyway
'         '                                           '------'
.         .   
'- - - - -'

[*] Could double-dash the horizontals to match the verticals:
-                                                                                ."".
.--  --  --. Would be much more useful to have single characters                ,   ;
|          | for horizontal and vertical dashed lines                          ,    ;
                                                                              ,     :
|          | .".       +====+                                           .""""'       `
             = =       "    "        `                 .---.   .""""".  :             `
|          | '"'       "    "         `                |    \  ;     ;  '""">       .""'
'--  --  --'           +====+          `               :     : ;     ;              ;
                                   +    `               \    | '"""""'              v
.- - -. .--. @@@@@ ,---, \      / , `    '- - - - -      '---'
;     ; i  i @wow@ |   |  `    , +   +                 .- -.   .- -. .- - - -. .-------.
'- - -' '--' @@@@@ '---'   `  ,   ` ,      /    |      :    `  '   ' ;       ; |       |
                            \/     +     -;     ;      ;     ; ;   ; ;       ; |       |
        .- - -.                            \     \      `    : '- -' ;       ; |       |
       ,       `                                         '- -'       '- - - -' '-------'
      ,         `
     :           : 
     ;           ;
     :           :
      `         ,
       `       ,
        '- - -'

Damn. Dashed horizontal lines suffer from the lack-of-abandonment problem.
"- -( -)*" won't match "  - - -  " properly because it will consume a space
after the last dash and reject.
                          |
.""". +....+ .- - --|  +'''''+'''>
;   ; : yo : ;      | -:     :
'"""' +....+ '- - - |  +.....+...>
                          |
+- +----     --- ---
 \/ \_/\/    \/\_/\/
 d   s d      s d  s

[*] Use "- - (- )*" as pattern
- Allows " - - " and " ------- "
- Dies for " -- - - -- ", but user can put a "+" in to delimit

[?] Ok, how should dashed corners work?
- Corners need metadata to tell them the types of lines surrounding the corner.
- Corner can then draw using one of the 2 types (solid should probably take precedence)

M_LINE_END_E
M_LINE_DASH_E  <-- but I might have more line styles.

[?] Are any other styles going to involve restyling the corners, though?
- Probably not. There isn't much more that can be done with simple attributes.
  Further corner styling would mean having custom code to render them, and I 
  probably won't go to that level.

- Crow's feet next

[!] Lines are slow
- Suspect this is because instances are accumulated from each space and all iterated
  through on each subsequent space until the space below is arrived at and the match
  can be rejected.
[*] Option 1: have patterns put to sleep while they're waiting for the space below. The 
  main program would have to have a map of positions to sleeping patterns which are to
  be woken up. Patterns waiting on non-existant spaces would have to be cleaned up after
  each line
[*] Option 2: Have lines put meta *in* first space at start, and *after* last place at 
  end. This would allow for early rejection of both lines and corners.

- I should make this change next.

      term         More like:   M_LINE_START_S
    for this?    start  after   M_LINE_AFTER_S
       v           v      v     M_LINE_START_E
-------            -------      M_LINE_AFTER_E
      ^                         M_LINE_START_SE
     term                       M_LINE_AFTER_SE
   for this?                    M_LINE_START_SW
                                M_LINE_AFTER_SW
  _        _                                   * 
 (''  o   '')    O    O                *\o    o|  *\o/*  O   O     
 -|-  +  -/_\-  -|-  -|-   <)->   <-(>   |-*  /\    |   -|- -|-  =(^w^)=
 / \  ^   | |   | |  / \                / >  * /<  / \   V  / \

 vv v v    not flipped: meta/char, meta
-<| |>-        flipped: meta, char, meta.

 lb l b
 vv v v    not flipped: meta/char, meta
->| |<-        flipped: meta, char, meta

I should make the same metadata change to boxes too, to facilitate
upward arrow patterns.

 vv   vv   NF meta/char, meta
-<|  |>-    F meta/char, meta 
                               
 vv   vv   NF meta/char, meta
->|  |<-    F meta/char, meta   

- For general-purpose boxes such as tables and things, connected boxes should
  be properly recognised. Or rather, the box pattern should reject connected lines

+---+  +----+    +-------------+    /---\     .---.    .-----.
|yep|  |nope|    |             |    |spc|    ( spc )  /       \
+---+  +----+--  +-------------+    \---/     '---'  (         )
                 |yep          |                      \       /   .
  +=====+        |(specialised)|   .----.    /    \    '-----'  .' '.
  "     "        +-------------+  / spc  \  / what \     n    .'feed '.    y
  "     "        |             |  \      /  \ next?/  ---<---:   the   :--->---
  +=====+        +-------------+   '----'    \    /           '. cat?.'       
       || "                                                     '. .'
       || "                                                       '
=====  || "                                                               
                                                                  
[?] Should all enclosed lines be recognised as boxes?
- This would be difficult to acheive because metadata must be output as
  pattern is being matched


Diagram types:

# Entity Relationship
	- Attributes (circled)
	- Entities (boxed)
	- Relationships (diamonds)
	- Primary keys (underlined)
	- Chen                   .
	               +---+N  .' '.  1+---+
	               |   |--:     :--|   |
	               +---+   '. .'   +---+
                             '
    - IDEF1X       +---+           +---+
                   |---|*- - - - <>|---|
                   +---+           +---+
                   
    - Bachman      +---+          +---+
                   |   |*<|------O|   |
                   +---+          +---+
                   
    - Martin / IE / Crow's foot           >O--  0 or more
                   +---+          +---+   >|--  1 or more
                   |   |>O-----||-|   |   -||-  1 and only 1
                   +---+          +---+   |O--  0 or 1
# Class diagram
    - Classes (boxed, 3 sections)    +----.
    - Relationships (lines, arrows)  |wot|_\
    - Notes (folded corner box)      | up  |
    - Inheritence (empty tri arrow)  +-----+   ----- |      ----- |
    - Composition (empty/filled diamond)        /_\  |<|--    ^   |<>---
                                 +---+           |   |        v   |                .----.
# Server deployment             /   /|    __    _____         |                    '----'
	- Nodes (3d boxes)         +---+ +   /_/|  /____/|  _________________    _     |    |
	                           |   |/    |_|/  |    || /________________/|  |_|[ ] '----'
	                           +---+           |____|/ | +--+ +--+ +--+ ||    __  ______
# Data flow diagram                                    | |  | |  | |  | ||   (__)(______)
	- start/end (circle/box/rounded)                   | +--+ +--+ +--+ ||   |  ||      |
    - arrows                   +---------------+       |________________|/   '--''------'
    - processing (box)        / read username /      .
    - I/O (parrallelogram)   +---------------+|    .' '.  y
    - conditional (diamond)                   +-->: ok? :---->
                                                   '. .'
# Sequence diagram                                   '                    
    - Boxes                   ;
    - Dashed lines            ;-----> 
    - Arrows             O    ;
    - Stick figures     -|-   ;<-----                                         .-------.
                        / \   ;                     .-----.    .---------.   /         \
# State machine diagram                 .-------.  / fooo  \  /foo bar foo\ |           |
    - Circle boxes             ( foo ) ( fooobar ) \  baaa / | bar foo bar ||           |
    - Filled circle                     '-------'   '-----'   \foo bar foo/ |           |
    - Circled filled circle     (#)-->((#))                    '---------'   \         /
                                 |      ^                                     '-------'
                                 |      |
                                 '------'   .----.     ; :
Box connectors:                            /      \    ; :
  |-----  --------------------   ^        ;        ;   ; :
  |<----  | ^/_\| * V V V ^ ^    |        |        |   ; :
  |<|---  | | | =/_\| - 0 V #    ;        ;        v   V V
  |-||--  | | | | | | | | | V     \      /
  |*<|--  | | | | | | | | | |      '----'
  |>----
  |>|---
  |>O---
  |<>---
  |<#>--

pclass()
pclass().next()
					curr = yield
-> None
pclass.test("a")
					-> "a"
					curr = yield occupied
-> occupied
pclass.test(" ")
					-> " "
					return
-> StopIteration


At each stage in the pattern we move forward by some amount. The position we 
are trying to reach may or may not actually exist, because of line endings 
and the end of the input. This this applies to consuming a single character, 
too.

[ ][ ][.][-][-][.][,n]
[ ][ ]['][-][-]['][n]
[ ][ ][|][ ][ ][|][n]
[ ][ ]['][-][-]['][n]
                                                                           ^
    /\                                       ^         '                 /   \ 
  /    \     /\   y     /\     .'.          / \      /   \       ^     /       \
/        \ /ok? \--->  /ok\---:ok?:--->    <   >   :       :   <   > <           >
\        / \    /      \  /    '.'          \ /      \   /       v     \       /
  \    /     \/         \/      |            v         .                 \   /
    \/        | n               v                                          v
              V                                          .'.    [ sq ]
                                 /    \   y            .'   '.           .--.
       /'\        .        --->-<  ok  >------>       <       > ( cl )  (    )
/  \ /     \    .' '.       _    \    /                '.   .'           '--'   .'.
 ok <  ok?  >  :     :    _- -_     |  n                 '.'    < dm >         <   >
\  / \     /    '. .'    -_   _-    +---->                                      '.'
       \./        '        -_-
   _     _                         +--------------+  Can't have box separator
  |\  ^  /|       /         \      | FooFactory   |  lines as separate pattern
    \ | /        /_|       |_\     |--------------|  because box's representation
     \|/        /   \     /   \    |              |  would have to change to
   <-- -->           +---+         |              |  incorporate section shading
     /|\         \_ /     \_/      |--------------|  
    / | \         \|      |/       | makeFoo()    |  
  |/_ V _\|        \      /        +--------------+  
    

+---------+ +---------+ +----+----+----+   .-----.
| Foobar  | | Foobar  | |####|////|####|   '-----'
+---------+ |---------| +----+----+----+   |  |  |
| foo     | | foo     | |    |....|    |   |  |  |
| bar     | | bar     | +----+----+----+   '-----'
+---------+ |---------|
| foobar()| | foobar()|
+---------+ +---------+
        
[!] Separator lines cause an issue in that using a + at the edges is ugly
	(especially for cylinder), and not requiring them means that all lines
	in content must be incorporated into pattern and cause it to fail if
	they're not separators. This is because we need to output the occupied
	meta flag for them, even before we know they span the whole pattern.
	
 .---+---.      .-----.
(  A | B  )    /       \
 '---+---'    (---------)
               \       /
                '-----'

[!] If we dont use +, people will expect to be able to use it anyway.
- Meh. Plus the lack of + is more explicit as a separator vs connected 
  boxes.

[*] Separator just means you have to commit to the line if one starts at
	the top or left edge:
	
+-----+ +-----+ +-----+ +-----+ +-----+ +-----+ +-----+
| |   | | |   | |-----| |-    | |  ---| |     | |     |
| |   | |     | |     | |     | |     | | |   | |     |
+-----+ +-----+ +-----+ +-----+ +-----+ +-----+ +-----+
  yes     no      yes    no       yes     yes     yes

[!] Separator intersections make for a bit of ambiguity when it comes to
	nested boxes:
-	                       +------------+
+-----+ This input will    | |        | | Instead of a nested box
|+---+| yield a box that   |-+--------+-| like the user might expect.
||   || looks like this:   | |        | |
|+---+|                    |-+--------+-|
+-----+                    | |        | |
                           +------------+
+----------+                     +-----+
| |      | | Disallow separator  |--.  | <- not allowed
|-+------+-| at border?          |  |  | 
| |      | |                     |  '--|
| |      | |                     +-----+
|-+------+-|
| |      | |
+----------+

[?] *Could* separator grid be a separate pattern?
- could draw background rects separately
- but would need to parse out the shape of the box
- how to detect *surrounding* box?

+---------------+
|   +--{-------+|   
|  /    |     / |  
| /     |    /  | 
|+-------}--+   |
+---------------+

[!] Meta flags dont provide efficient access to the *inside* edges of box.
[!] Its going to be super awkward to deal with things like cloud boxes

  .------.   - I think practically it has to be implemented as part
 (  |  |  )  of the same pattern
(---+--+---)
 (  |  |  )
  '------'

[*] Restrict separators such that they must have at least 1 char content?
- done right, could still allow full-width lines and not have dumb false
  positives for the separators

+------+    This input would    +------+    This input would 
|------| N  match, giving a     |------| N  be rejected, because
|------| Y  box separated in    |------| Y  the last line would 
|------| N  the middle with     |------| N  start to be parsed
+------+    two addition horiz  |------| Y  as a separator,
            lines.              +------+    yielding a 0-height 
 N    N                                      section.
+------+    This input would    
|+----+| N  yield nested boxes.  The right and bottom lines are  
||    ||    Top and left lines   not valid separators either,  
||    ||    are not recognised   because they start with plus 
|+----+| N  as separators        signs without intersecting 
+------+                         another separator.


[!] Damn. Patterns can't be self-similar. The intersections of the box 
    section separators can themselves form boxes which are accepted 
    before the outer box is completed, causing it to be rejected.
    
+-----+         Would losing the + help? It would solve the immediate
| | | |         problem, but would it be intuitive? I guess intuitiveness
|-+-+-|   +-+   has to to come after functionality.
| | | | = | |   
|-+-+-|   +-+   +-----+  Could allow user to use either | or - at 
| | | |         |  |  |  intersections, as long as they don't use +
+-----+         |--|--|
                |  |  |
                +-----+
[!] Nesting separated boxes highlights an issue: the correct z level
	for the background is going to depend on the nesting level.
	
[?] Will an outer box always be at a lower x and y?
- if so, the z can be based on the position.

+---- z -2   ----+ doesnt matter
|+--  z -1       |  +---
||               |  |   

Box background z level must be between -1 (the background) and 0 (the foreground).
Pattern doesnt know how large the image is.

[*] Could have the z *approach* 0 asymtoticaly.
- Such a hack, but it'll work for the time being at least.

Need to add stroke & fill alpha properties to all shapes

+---+---+---+---+  Only need 0, 0.5 and 0.25 shade levels
|###|:::|###|:::|  for section fills
+---+---+---+---+    |
|:::|   |:::|   | <--' 
+---+---+---+---+    
|###|:::|###|:::| 
+---+---+---+---+
|:::|   |:::|   |
+---+---+---+---+

[!] If I use alpha'd rectangles for box background, nested
	boxes backgrounds blend in an undesirable way. If I try
	to use calculated fill colours, I have to have a way of
	translating colour strings into their rgb values.
- I could disallow colour names as input
- I could add an additional, background-coloured rectangle
  behind the box

- Ok the blending actually isn't as bad as I thought. The colours
  just get darker with each nested level. I can live with that.

- I think zs of nested boxes are fine too, seeing as the backgrounds are semi-transparent

[!] Length-1 lines are accepted, but this means that punctuation in the middle of text is 
	transformed into line segments. Can't limit lines to 2 or more length because twisty
	lines with single-char segments are common. Corners are defined by lines, not the 
	other way round.

[?] What would dashed circle boxes look like?

 .----.   .- - .   .- - .
(      ) (      ) :      :
 '----'   '- - '   '- - '
 
  .----.     .- - .
 /      \   ,      `
(        ) :        :
 \      /   `      ,   
  '----'     '- - '

   .'.        .'.
 .'   '.    .     .
<       >  <       >
 '.   .'    '     '
   '.'        '.'
   
   +----+ +- - +  .----. .- - .
  /    / ,    ,  /    / ,    ,
 /    / ,    ,  /    / ,    ,
+----+ +- - +  '----' '- - '

I think dashed circles and diamonds are a lost cause - there's only
so much one can do.
 ____    _ _ 
/ MF \  , MF `
\____/  `_ _ ,

+- - - - - +  Dashed boxes should use the same solid separators as solid
; | | | |  ;  boxes. It's just messy, confusing and ambiguous otherwise.
;-|-|-|-|--;
; | | | |  ;
;-|-|-|-|--;
; | | | |  ;
+- - - - - +           +-----+
                       |     |
 core                  |     V
  |                    ^   ptests
  +--->---+--->---+    |     |               
  |       |       |    |     |               
  |       |       +->--+-->--+---->----+---->------+----->------+
  |       V       |          |         |           |            |
  |    patterns   ^          V         V           V            V
  V       |       |       boxtests linetests connectortests icontests
 main <---+--->---+          |         |           |            |
  |               |          +--->-----+-->--+--<--+-----<------+
  +------>--------+                          |
                                             V
                                          alltests

core
patterns
main
ptests
boxtests
linetests
connectortests
icontests
alltests

Literal markers?
                   
<%  This should     %>
<% not be a pattern %>

They're ugly but probably going to be necessary for practical reasons

66 foobar 99

66 please take   99  <-- *might* be assumed to 
66 me litterally 99      be a box when multiple 
66    ;) ;)      99      lines involved, but short
66    ;) ;)      99      inline 66sections99 will be confusing

In fact this is a totally dumb syntax:

+-------------------+
| 66 | 51 | 42 | 99 | <-- this line makes the 
|-------------------|     whole box pattern fail
| 23 | 11 | 57 | 21 |
+-------------------+

[!] I want to detect alpha character either side of lines, but this requires
	checking the character *before* the pattern itself.
	
       [a][/][b][ ][ ...	
...][ ][/][ ][ ][ ][ ...
...][ ][ ]

Every non-alpha character will spawn a line pattern check for 1 space.

We much prefer patterns that have a definite start character.

[*] Should text be parsed out first?
- i.e. have a "word" pattern, which is a string of alpha characters, and which
  sets WORD_START_E and WORD_AFTER_E meta flags.
- this would have the side benefit of making the text output more efficient.

 foo/bar     foo /bar     foo / bar    foo(); bar
         N            N             Y              Y
 
 foo/bar     foo/ bar     foo; bar     foo; bar    Y
   /     Y            N             N     ;

[?] What syntax already uses alpha characters?
- down arrows
- up crows feet
- stick man
- tiny ellipse
- literals, obvs

It's a possible. But checking the leading character is simpler to implement, 
so I'll go for that (first, at least).

[*] Could pass in current and previous characters as input
- This would have to be previous *on same line*
- Bit hacky?

[!] Context for character before doesn't work, because it's optional.

 starting here fails
    v
   [a][/][ ]
       ^
  but starting here passes
  
[*] Introduce START_OF_INPUT in addition to END_OF_INPUT, and *require* 
    proceeding character.
- Actually, don't need START_OF_INPUT because we can test the position.

[!] At left edge, context should be *optional*, not unexpected

[/][ ][ ]
 ^
[a][/][ ]
 ^
[ ][a][/]
    ^

Position 0,0. Do we expect context, or the line itself? If only allow one or 
the other, either the lines at position 0 or lines at position 1 are not 
possible. If we allow both, the context restriction is relaxed for that position.

[*] Could introduce START_OF_LINE. This could then act as the left context 
	character for the left edge.
- Seems like a lot of work just to make a particular pattern work. 
- Won't help if a pattern ever needs ABOVE context and BELOW context
- Mirrors "\n" character

[S][/][ ][ ][E]
 ^
[S][a][/][ ][E]
    ^
[S][ ][a][/][E]
       ^
[?] Would the newline character suffice?
- Would need START_OF_INPUT for first character's context
- Would have to not apply context rule if context is newline, though a newline
  isn't a text character anyway

[?] How should separators for non-rectangular boxes work?

    +---------+   .-----.      .'.      .------.
   /| | | | |/   /| | | |\   .'| |'.   (| | | | )
  /---------/   (---------) <-------> (----------)
 /| | | | |/     \| | | |/   '.| |.'   (| | | | )
+---------+       '-----'      '.'      '------'

- Ideally user would be able to start a separator partway down the box
  - horizontal or vertical.

Going to leave out separators for other box types, for now. They're not
that high on the priority list.

But, one option would be to only allow separator lines on the repeated
part of the box edge:
  
     vvvvvv           vvvvvv
    +----------+     .------.         .'.
   /-|----|---/ <   /-|----|-\  <   .'   '.
  /  |    |  /  <  (  |    |  ) <  <       > ?  Meh.
 /---|----| /   <   \-|----|-/  <   '.   .'
+----------+         '------'         '.'

    (*)-----+    vv          v
    /      /    >.'.        >.        .    .'.
   /      /    .'   '.     .' '.     < >  <   >
  /      /   .'       '. .'     '.
 +-----(*)

4(c-1)+3     4(c-1)+3+2a
     .
   .' '.        .'.
 .'     '.    .'   '.
<         > .'       '.
           <           >
     
[?] Can we efficiently detect whether a line starts / ends at a box?
  
  meta    read on
    v        v         ?
[|][-][-][-][|]        v [|]    [-][-][-]
                      [/][|]    [|] < meta
   meta         [|][/][ ][|]    [|]
[|] v           [|] < read on   [-][-]
[|][\][ ]                        ^
[|][ ][\][|]                   read on
[|][ ][ ][|] < read on
                           Lines with non-negative x and y
[-][-][-][-]               directions are covered by meta flags
[ ][\] < meta              We got away with it for arrowheads
[ ][ ][\]                  because they only had 4 directions
[-][-][-][-] < read on     

[?] Do we even care about diagonal lines?
- It's a nice-to-have, even for h/v lines

[*] Just implement it for horizontal and vertical lines for now

- SW line is still progressing forwards through the input, it's just
  we need a couple of extra meta flags:
  
     [##][ e]    [-][#] [\]   Y[|]   Y[/] [#][-] [#] Y  [#]     [#]
 [sw][ s][se]     Y      Y [#] [#] [#]     Y        [\] [|]Y [/]Y
  ^       ^                 

[?] Downwards outline arrows?

/_\          _|_   I think that's the best
 |  <|-  -|> \ /   that can be done

0.8
--
.'   | 0.5
----
'.

[!] Damn. Outline arrowhead requires line metadata to attach to, but
	characters it uses are interpreted as line segments first.

^  The alternatives are terrible
T 

What if the arrowhead absorbed the line part. It could still set the 
line metadata. Nope, would have to absorb the *whole* line.

Line connectors are only going to need individual line-like characters 
- i.e. they wont need any runs of lines like ---

[?] Could short lines be parsed separately?

Long lines
Connectors  <-- but then connectors can only connect
Short lines     to lines of length 2 or more.
Corners

|yes  |no  | no
|>--| |>-| |>-.
|     |    |  |

[?] Can I disallow all length-1 lines?
- That's pretty drastic

<--.    <-. no
   |yes   |
   |      '-
   '--

[?] Could I remove the requirement for connectors to be attached to lines?
- but then how would arrowheads be distinguished from crows feet. Also every
  angle bracket would be affected.

[*] Disallowing connectors on length-1 lines is the most pragmatic solution
- Its still a pain, though:

/_\    /_\    ^      ^      If I made a special case for <- arrows, would it
 | yes  | no  | yes  | no   be any better? It would provide more flexibility
 |            |             for the most common type of arrowhead, but it
                            would be counter intuitive that the two types 
                            work differently.
Used by connectors: | - / \ 

Everything is based on lines so they have to be parsed first, but they're so
fundamental that they're found in other patterns!

  |-----  --------------------
  |<----  | ^/_\| * V V V ^ ^
  |<|---  | | | =/_\| - 0 V #
  |-||--  | | | | | | | | | V
  |*<|--  | | | | | | | | | | 
  |>----                                                                   
  |>|---  The line characters used in the connector patterns *almost* all  V
  |>O---  have some other characters either side of them, apart from:      -
  |<>---  And checking the character above for context would be a killer.  |
  |<#>--

- I'm just going to go with the length-1 line thing.

[!] Length-1 dashed lines?
- Don't exist.

[<][|][ ]                                                              --------+
[|][>][ ]                                                                       \
                                                            .-----.              \
Circle vs Hex boxes: .------.                 .-----.     .'       '.             \
          .---.     /        \      .----.   /       \   /           \             +----
( sml )  (     )   (  large   )    /  ?   \ |    ?    | |      ?      |           /
          '---'     \        /     \      /  \       /  |             |          /
                     '------'       '----'    '-----'    \           /          /
                      ______                              '.       .'+---------+      
          ____       /      \     +----+                    '-----' /           \
         /    \     / large  \   /      \   ___       __           /             \
         \____/     \        /  +   ??   + | ? | ?_  /??\         /               \
   +                 \______/    \      /  |___| <_> \__/    ----+                 +----
  / \                             +----+                          \               /
 /   \   +---+ ____  .---.              ___    ___     ___     ___ \             /
+     + /   / /   / <     >   .----.   /   \  /   \   /   \   /   \ \           /
 \   / +---+ /___/   '---'  .'      '. \___/ <     > {     } +     + +---------+
  \ /                      <          >       \___/   \___/   \___/ /           \
   +  I'm actually starting '.      .' +--+   +---+     +-+        /             \
      to warm to the + corner '----'  <    > /     \   /   \      /               \
      variant of the hex box.          +--+  \     /  + hex +    +                 +
 It's consistent with the + corner idea, but...---+    \   /      \               /
                                                        +-+   
It's ugly, it imposes a significant minimum size, and there's no specific
need for it to be consistent with the way straight lines are implemented.
Then again, it does allow connectors to be vertically centered.

[!] A disadvantage of using + connectors for any type of box is that boxes may be parsed
out of larger structures which aren't intended to contain them. This is actually a 
problem with square boxes, e.g.

+------+------+------+------+  A, C, I and K become boxes.
| A |  | B |  | C |  | D |  |  But we can't put restrictions on what the corners
|------|------|------|------|  are allowed to connect to, because the corners are
|   |  |   |  |   |  |   |  |  the natural place to put connectors in the case of
+------+------+------+------+  hexagonal boxes.
| E |  | F |  | G |  | H |  |         <-----.            <----+         ____
|------|------|------|------|   ______      |          _____   \___    /    \
|   |  |   |  |   |  |   |  |  | A    |   ______      /     \  /   \  /      \---->
+------+------+------+------+  |better|  /     / .'.  |     | |     | \      /
| I |  | J |  | K |  | L |  |  |  box?| /     / <   > |     | |     |  \____/
|------|------|------|------|  |______|/_____/   '.'  \_____/  \___/
|   |  |   |  |   |  |   |  |      |
+------+------+------+------+      '---->

[?] Is the only way to separate boxes properly from more general line structures to 
have their patterns not be composed of lines by the same rules?

[?] Is it not possible to parse boxes out more tentitively?

  +---+        Box or structure?                  +----+ A box, with box semantics,
 /     \       When does a box with things        |    | or just an enclosed line, like
+       +----> meeting it become a more general   |    | this would be?   +-+
 \     /       structure of lines that should     +----+  |               | |
  +---+        be left alone?                             '-->  +---------+ +
                                                                 \         / 
                                                                  +-------+
What would happen if overlapping pattern instances cancelled each 
other out instead of the first one being accepted?

+--+--+  Then simple lines wouldn't be possibe: -------
|  |  |
+--+--+

:     :     :     :   ;   ;   ;   ;
 '. .' '. .' '. .'     \ / \ / \ /
   :     :     :        ;   ;   ;
 .' '. .' '. .' '.     / \ / \ / \
:     :     :     :   ;   ;   ;   ;

[*] What if using + corners as connectors was discouraged, and invalidated the box?
    Could use the hex box variant without + corners. Nobody's going to want to attach
    connectors to square box corners anyway.
                
                  +----+      _____
       |   |     /  A   \    /  A  \--->
+---+  +---+--  +  hex   +  /  hex  \      ^   
| Y |  | N |     \ line /   \  box  /      |
+---+  +---+--    +----+     \_____/       +
                  |    |           \      /
                  V    +-->         +----+
                  
[!] Underscores suck a bit for boxes, because lines at the top leave a big gap:

   +----->
   |
 _____
/     \

[!] People WILL use square box corners to attach things, especially diagonally:

+---+
|   | box A
+---+
     \
      +---+
      |   | box B
      +---+
