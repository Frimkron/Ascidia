2D Parsing

[!] Best way to parse an array of characters, identifying symbols made up of
	multiple lines of characters. Symbols would be defined as 2D patterns - 
	the 2D equivalent of regular expressions
[!] Best way to define 2D symbols

     a
  +-----+     a == b
c |     |     c == d
  |     | d
  +-----+
     b

  \+(-+)\+\n         |$1| syntax gets length of match
  (\| {|$1|}\|\n)+   Wow that expression is ugly
  \+$1\+\n           Successfully collapses 2d symbol into 
                     1d regex, though

Special part is the handling of newlines - newlines continue from symbol
on next line down from start of pattern


\.(-{5,})\.\n         These really are horrendously ugly.
('-{|$1|}'\n)         They look nothing like their resulting symbol
(\| {|$1|}\|\n){1,}   Might be a way to bootstrap the parsing chain, anyway!
$2                    Could use linear regexes to parse the symbol definitions,
                      whatever they're going to look like

      left     left
( + )-->--( - )-->--( + )
  |        ^ |
  v        '-'
  |down     left
( | )-.
  | ^ | down
  v '-'
  | down
( + )

[!] Newlining to a space *before* the start of the line above
- would need syntax for going back spaces, e.g. "^{5}"

  /\
 /  \   Diamonds:
/    \  (/( {$L*2})\\\n)+
\    /  (\\( {(|$1|-($L-|$1|))*2})/\n)+
 \  /
  \/    Diamond isn't possible without quantifiers proportional to 
        line number and other crazy arithmetic in the quantifier 
        bracket

[!] Need to *record* state in order to linear-ise some of these patterns.

REs deficiency for this problem is equivalent to the following 1D problem:

	all 2:1 ratio forms of "sssshh"

Here we'd need to remember the number of S's in order to match the H's.

[?] Can a more general grammar express this?

S -> A
A -> 's' 's' B 'h'
B -> A | e

sssssshhh:

S
'-- A
    |-- 's'
    |-- 's'
    |-- B
    |   '-- A
    |       |-- 's'
    |       |-- 's'
    |       |-- B
    |       |   '-- A
    |       |       |-- 's'
    |       |       |-- 's'
    |       |       |-- B
    |       |       |   '-- e
    |       |       '-- 'h' 
    |       '-- 'h'
    '-- 'h'

[?] Ok, so what about 3:2:1 ratio forms of "aaaggh" ?
- Yeah I haven't got a clue, there. Nothing springs to mind. Its not a case of finding
  an X for every Y, so the presence of a stack won't help - a bespoke algorithm is 
  required.

(aaa)+(gg){|$1|}(h){|$1|}
            ^
          Have to refer to a variable in which we store 
          the number of times we've matched something.

( "Scream" (
	( one-or-more 
		( capture-group
			( "a" "a" "a" )))
	( let x 
		( size-of
			( backref 1 ))
		(
			( n-of x ( "g" "g" ))
			( n-of x "h" )))))
				
S-Expressions are a data representation. They're merely nested lists. There are 
parentheses, symbols, strings and numbers (afaik). What the nested lists represent 
is entirely up to the application.

[?] How is lisp evaluated? 
- I guess each component is evaluated in order. 
[?] How does lisp recognise a function?
- I guess there's logic that looks up the first symbol of of list to see if its a 
function. I wonder if every list starting with a symbol is assumed to be a function.
- I guess the interpreter could make a decision based on what it finds in the list. 
The first atom in the list would dicatate how to continue to evaluate it.

- Lisp evaluates lists by treating the first atom as a function name and the rest
as arguments. However, macros can override this to create arbitrary syntax.

- So I could do the same - have a fixed set of functions with their own evaluation
  rules. The language doesn't even need to be turing complete.
- The program could evaluate lone string literals by attempting to consume that 
  character, returning a boolean to indicate success.
  
(def-symbol "box"
	(with-vars (first-line mid-bar) 
		(capture first-line 
			(one "+") (capture mid-bar (one-or-more "-")) (one "+") (eol))
		(one-or-more (one "|") (n-of (width mid-bar) " ") (one "|") (eol))
		(one first-line)))
		
- fn def-symbol name stmt stmt ... -> nil
		defines a new symbol pattern
- fn with-vars (var var ...) stmt stmt ... -> nil
		creates variables for the scope of the statements
- fn capture var stmt stmt ... -> nil
		buffers consumed input for inner statements and stores it in var. The buffer
		is built as the statements are evaluated.
- fn one str str ... -> boolean 
		attempts to consume the given list of strings		
- fn one-or-more str str ... -> boolean
		attempts to consume the given list of strings at least once. Returns true
		if this was the case, false otherwise
- fn zero-or-more str str ... -> boolean
		attempts to consume the given list of strings multiple times. Returns 
		true regardless of how many times this succeeded
- fn zero-or-one str str ... -> boolean
		attempts to consume the given list of strings once, returning true whether 
		it succeeded or not
- fn n-of n str str ... -> boolean
		attempts to consume the given list of strings exactly n times, returning 
		false if this fails
- fn width str -> int
		returns the width in characters of the given string - that is, the length
		of the longest line.
- fn height str -> int
		returns the height in characters of the given string - that is, the number
		of lines it contains.
- fn eol [int] -> nil
		indicates the end of a pattern's line. Can specify the relative offset of 
		the new line start position in characters. 0 or unspecified indicates the 
		new line begins directly under the current one. -2 indicates the new line
		begins 2 characters left of the current one.
- fn - int int ... -> int
		subtracts the given integers from one another, returning the result
- fn + int int ... -> int
		adds the given integers to each other, returning the result
- fn * int int ... -> int
		multiplies the given integers with each other, returning the result
- fn / int int ... -> int
		divides the given integers by each other, returning the result
		
(def-symbol "diamond"
	(with-vars (top bottom)
		(capture top 
			(one-or-more
				(one "/")
				(n-of (- (height top) 1) " ")
				(one "\\")
				(eol)))
		(capture bottom
			(n-of (height top)
				(one "\\")
				(n-of (- (height top)(height bottom)) " ")
				(one "/")
				(eol)))))

This definition relies on being able to monitor the height of a captured
buffer as it is being buffered.

[!] I need a special function, like the newline function, to indicate empty space
    i.e. characters which are allowed to have other patterns occupying them.
    For example, a box is allowed to have other patterns inside it.

[!] Patterns need to be able to look ahead to what the *next* character is.

Pattern: bc

[a][b][c][d]  [a][b][c][d]  [a][b][c][d]  [a][b][c][d]
 ^                ^                ^                ^
next (nope)     next (make)      next (more)      next (complete)

[!] Need an arbitraty length of look-ahead e.g: "a(bcdef)?
    i.e, backtracking
    
X: a(bcdef)?
    +
Y: abc
 =                
                   
   a     b     c     d     e     f
(s)-->(1)--> 2 -->(3)--> 4 --> 5 -->(6)
       X           Y                 X

[!] Buildup of potential patterns

a+
    
a a a a a a a a a a a a a a a 
V_/_/_/_/
  V_/_/_/
    V_/_/ ....
      V_/
        V
        
[!] Pattern priorities

              b eliminates    d eliminates
               a and c         b, freeing up a and c
                  v             v
- - - - - - - - - - - - - - - - -
    \_____________/
  \___/ b \___/ \_______________/
    a       c           d

- Patterns have a priority order
- Scan the canvas from left to right, a line at a time. 
- For each patten in the ongoing list in priority order, test whether they accept the 
  current character
- Pattern will return "more", "complete" or "aborted" to indicate their state.
- "Aborted" means the pattern didnt match - it is removed from the ongoing list.
- "More" means the pattern accepted the character but is not complete yet
- "Complete" means the pattern is fully matched - the matching pattern is recorded as
  a potential pattern position
- Identify any patterns which might begin with the current character and add them to
  the ongoing list.

[*] Why not get it working the simplest way first - make a pass for each pattern, in
    priority order, trying to find matches

[?] Any reason why I shouldn't discard other ongoing instances of the same pattern 
    upon finding a match?
- Matches are greedy, I think

ababab
a b a b a b a b
\_________/
    \_________/     Should be ok
        \______
            \__

[?] Can we get away with not allowing any other ongoing instances at all?

bbba
b b b b a
\_____x
  \_____/    No, we would miss valid matches.
    \___x
      \_x

[*] Upon matching multiple instances of the same pattern at once, should accept the 
    oldest one.

[!] Discarding ongoing patterns fails for multi-line patterns. Such patterns are 
    allowed to overlap (effectively)

[!] Ongoing instances need to somehow record the characters they consist of, so 
    that other overlapping instances are aborted upon finding a match.
    
[?] In what way should the transformation from ascii pattern to vector be
    defined? 
- For each matched pattern, the constituent cells and their contents must 
  be recorded. 
- The pattern will need to note the positions of particular vertices and such.
- e.g. for the database cylinder, matcher would note the height of the top
  and bottom circles, and the width and height of the overall pattern
  
          .--------.   ^ top      - Having noted these values, pattern can
       ^  '--------'   v height     later return the necessary shapes, positioned
bottom |  |        |                relative to the first cell of the match
height |  |        |   ^ bottom   
       v  '--------'   v height
          <-------->
            width

[*] Storing values can be boiled down to recording the current cell position
    in various variables during the match - noting key locations for later
    calculating widths and heights

[*] The current character can also be stored or tested during the match, in
    order to identify optional stuff

[!] Completed matches must be stored somewhere along with the cells they occupy
    so that they can be tested for on subsequent passes

[!] Some components such as box connectors need to test for what type of pattern
    a character is part of and, indeed, what aspect of the pattern the character 
    is - e.g. left or right side of a box
    
  .-------.  
 (         )
(           )
 (         )
  '-------'
