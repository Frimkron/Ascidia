2D Parsing

[!] Best way to parse an array of characters, identifying symbols made up of
	multiple lines of characters. Symbols would be defined as 2D patterns - 
	the 2D equivalent of regular expressions
[!] Best way to define 2D symbols

     a
  +-----+     a == b
c |     |     c == d
  |     | d
  +-----+
     b

  \+(-+)\+\n         |$1| syntax gets length of match
  (\| {|$1|}\|\n)+   Wow that expression is ugly
  \+$1\+\n           Successfully collapses 2d symbol into 
                     1d regex, though

Special part is the handling of newlines - newlines continue from symbol
on next line down from start of pattern


\.(-{5,})\.\n         These really are horrendously ugly.
('-{|$1|}'\n)         They look nothing like their resulting symbol
(\| {|$1|}\|\n){1,}   Might be a way to bootstrap the parsing chain, anyway!
$2                    Could use linear regexes to parse the symbol definitions,
                      whatever they're going to look like

      left     left
( + )-->--( - )-->--( + )
  |        ^ |
  v        '-'
  |down     left
( | )-.
  | ^ | down
  v '-'
  | down
( + )

[!] Newlining to a space *before* the start of the line above
- would need syntax for going back spaces, e.g. "^{5}"

  /\
 /  \   Diamonds:
/    \  (/( {$L*2})\\\n)+
\    /  (\\( {(|$1|-($L-|$1|))*2})/\n)+
 \  /
  \/    Diamond isn't possible without quantifiers proportional to 
        line number and other crazy arithmetic in the quantifier 
        bracket

[!] Need to *record* state in order to linear-ise some of these patterns.

REs deficiency for this problem is equivalent to the following 1D problem:

	all 2:1 ratio forms of "sssshh"

Here we'd need to remember the number of S's in order to match the H's.

[?] Can a more general grammar express this?

S -> A
A -> 's' 's' B 'h'
B -> A | e

sssssshhh:

S
'-- A
    |-- 's'
    |-- 's'
    |-- B
    |   '-- A
    |       |-- 's'
    |       |-- 's'
    |       |-- B
    |       |   '-- A
    |       |       |-- 's'
    |       |       |-- 's'
    |       |       |-- B
    |       |       |   '-- e
    |       |       '-- 'h' 
    |       '-- 'h'
    '-- 'h'

[?] Ok, so what about 3:2:1 ratio forms of "aaaggh" ?
- Yeah I haven't got a clue, there. Nothing springs to mind. Its not a case of finding
  an X for every Y, so the presence of a stack won't help - a bespoke algorithm is 
  required.

(aaa)+(gg){|$1|}(h){|$1|}
            ^
          Have to refer to a variable in which we store 
          the number of times we've matched something.

( "Scream" (
	( one-or-more 
		( capture-group
			( "a" "a" "a" )))
	( let x 
		( size-of
			( backref 1 ))
		(
			( n-of x ( "g" "g" ))
			( n-of x "h" )))))
				
S-Expressions are a data representation. They're merely nested lists. There are 
parentheses, symbols, strings and numbers (afaik). What the nested lists represent 
is entirely up to the application.

[?] How is lisp evaluated? 
- I guess each component is evaluated in order. 
[?] How does lisp recognise a function?
- I guess there's logic that looks up the first symbol of of list to see if its a 
function. I wonder if every list starting with a symbol is assumed to be a function.
- I guess the interpreter could make a decision based on what it finds in the list. 
The first atom in the list would dicatate how to continue to evaluate it.

- Lisp evaluates lists by treating the first atom as a function name and the rest
as arguments. However, macros can override this to create arbitrary syntax.

- So I could do the same - have a fixed set of functions with their own evaluation
  rules. The language doesn't even need to be turing complete.
- The program could evaluate lone string literals by attempting to consume that 
  character, returning a boolean to indicate success.
  
(def-symbol "box"
	(with-vars (first-line mid-bar) 
		(capture first-line 
			(one "+") (capture mid-bar (one-or-more "-")) (one "+") (eol))
		(one-or-more (one "|") (n-of (width mid-bar) " ") (one "|") (eol))
		(one first-line)))
		
- fn def-symbol name stmt stmt ... -> nil
		defines a new symbol pattern
- fn with-vars (var var ...) stmt stmt ... -> nil
		creates variables for the scope of the statements
- fn capture var stmt stmt ... -> nil
		buffers consumed input for inner statements and stores it in var. The buffer
		is built as the statements are evaluated.
- fn one str str ... -> boolean 
		attempts to consume the given list of strings		
- fn one-or-more str str ... -> boolean
		attempts to consume the given list of strings at least once. Returns true
		if this was the case, false otherwise
- fn zero-or-more str str ... -> boolean
		attempts to consume the given list of strings multiple times. Returns 
		true regardless of how many times this succeeded
- fn zero-or-one str str ... -> boolean
		attempts to consume the given list of strings once, returning true whether 
		it succeeded or not
- fn n-of n str str ... -> boolean
		attempts to consume the given list of strings exactly n times, returning 
		false if this fails
- fn width str -> int
		returns the width in characters of the given string - that is, the length
		of the longest line.
- fn height str -> int
		returns the height in characters of the given string - that is, the number
		of lines it contains.
- fn eol [int] -> nil
		indicates the end of a pattern's line. Can specify the relative offset of 
		the new line start position in characters. 0 or unspecified indicates the 
		new line begins directly under the current one. -2 indicates the new line
		begins 2 characters left of the current one.
- fn - int int ... -> int
		subtracts the given integers from one another, returning the result
- fn + int int ... -> int
		adds the given integers to each other, returning the result
- fn * int int ... -> int
		multiplies the given integers with each other, returning the result
- fn / int int ... -> int
		divides the given integers by each other, returning the result
		
(def-symbol "diamond"
	(with-vars (top bottom)
		(capture top 
			(one-or-more
				(one "/")
				(n-of (- (height top) 1) " ")
				(one "\\")
				(eol)))
		(capture bottom
			(n-of (height top)
				(one "\\")
				(n-of (- (height top)(height bottom)) " ")
				(one "/")
				(eol)))))

This definition relies on being able to monitor the height of a captured
buffer as it is being buffered.
